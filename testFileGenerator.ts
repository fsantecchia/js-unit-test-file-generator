import { transformFileSync, transformSync, Node } from "@babel/core";
import typescriptPreset from "@babel/preset-typescript";
import generate from '@babel/generator';
import prettier from 'prettier';
import * as fs from 'fs';

const FILE = './code-to-test.ts';
const LINE_BREAK = '\n';
const LINE_BREAK_DOUBLE = '\n\n';

const TEMPLATE = ({
  MODULE_NAME,
  TEST_CASES
}: {
  MODULE_NAME: string;
  TEST_CASES: string;
}) => {return `
  // File generated by blabla

  import ${MODULE_NAME} from '../${MODULE_NAME}'

  ${TEST_CASES}
`};

class App {
  isAsync = true;
  modules = [];
  selectedModuleName = '';
  selectedModuleParams: Node[] = [];
  testSuite: Describe; // main Describe
  tryCatchCases: It[] = [];
}
let APP = new App();

class LogicalBranchesGenerator {
  constructor(testNode) {
    this._testNode = testNode;
    this.generateDescribe()
    this.generateBranchesByTestNode(this._testNode, true);
    this.generateTestCases();
  } 

  private _logicalBranches = [];
  private _testNode: Node;
  private _describe: Describe = null;

  private generateDescribe = () => {
    const condition = '`if(' + generate(this._testNode).code.replace(/'/g, '`').replace(/\n/g, ' ')+ ')`';
    this._describe = new Describe(`Logical Branches generated by ${condition}`);
  }

  // testNode => path.node.test
  private generateBranchesByTestNode = (testNode: Node, isMainNode: boolean) => {
    if (testNode.type === 'LogicalExpression') {
      if (isMainNode) {
        this._logicalBranches.push({
          name: '`the condition returns true`'
        })
        this._logicalBranches.push({
          name: '`the condition returns false`'
        })
      }


      this.generateBranchesByTestNode(testNode.left, false);
      this.generateBranchesByTestNode(testNode.right, false);
    } else {
      this._logicalBranches.push({
        name: '`' + generate(testNode).code + ' returns true' + '`'
      })
      this._logicalBranches.push({
        name: '`' + generate(testNode).code + ' returns false' + '`'
      })
    }
  }

  private generateTestCases = () => {
    this._logicalBranches.forEach((branch) => {
      const itName = `should work when ${branch.name.replace(/'/g, '`').replace(/\n/g, ' ')}`;

      const it = new It(itName);
      it.generateStructure();

      this._describe.addTestCase(it)
    })
  }

  getDescribe = () => {
    return this._describe;
  }
}

class Describe {
  constructor(description) {
    this._description = description;
  }

  private _description: string;
  private _describes: Describe[] = [];
  private _testCases: It[] = [];

  addDiscribe = (discribe: Describe) => {
    this._describes.push(discribe);
  }

  addTestCase = (testCase: It) => {
    this._testCases.push(testCase);
  }

  finish = () => {
    return `describe('${this._description}', () => {
      beforeEach(async () => {});

      ${this._testCases.map((it) => it.finish()).join(LINE_BREAK_DOUBLE)}
    })`
  }
}

class It {
  constructor(description) {
    this._description = description;
  }

  private _description: string;
  private _lines: string[] = []

  addLine = (line: string) => {
    this._lines.push(line);
  }

  addEmptyLine = () => {
    this._lines.push(LINE_BREAK);
  }

  generateStructure = () => {
    this._lines.push(getParamsAssigment());
    this._lines.push(LINE_BREAK);
    this._lines.push(getFunctionCall());
  }

  finish = () => {
    return `it('${this._description}', ${APP.isAsync ? 'async' : ''} () => {
      ${this._lines.join(LINE_BREAK)}
    })`
  }
}

/* returns the param's name */
const getParamNameByNode = (paramNode: Node): string => {
  if (paramNode.type === 'Identifier') {
    return paramNode.name;

  } else if (paramNode.type === 'AssignmentPattern') {
    return getParamNameByNode(paramNode.left);

    // Object as param
  } else if (paramNode.type === 'ObjectPattern') {
    const params: string[] = [];
    paramNode.properties.forEach((innerParamNode) => {
      params.push(getParamNameByNode(innerParamNode.key))
    });
    return `{ ${params.join(', ')} }`;

  }
}

/* returns param1, param2, param3 */
const getParamsForFunction = (): string => {
  return APP.selectedModuleParams.map((paramNode) => getParamNameByNode(paramNode)).join(', ');

}

/* returns const param1 = 'REPLACE'; const param2 = 'REPLACE'; */
const getParamsAssigment = (): string => {
  const params: string[] = [];

  APP.selectedModuleParams.forEach((paramNode) => {
    // Object as params
    if (paramNode.type === 'ObjectPattern') {
      paramNode.properties.forEach((innerParamNode) => {
        params.push(getParamNameByNode(innerParamNode.key))
      });
  
    } else {
      params.push(getParamNameByNode(paramNode))
    }
  })

  const formattedAssigments = params.map((paramName) => {
    return `const ${paramName} = 'REPLACE';`
  })

  return formattedAssigments.join(LINE_BREAK)
}

/* returns const result = function(param1, param2); */
const getFunctionCall = (): string => {
  return `const result = ${APP.isAsync ? 'await' : ''} ${APP.selectedModuleName}(${getParamsForFunction()});`;
}

const getModules = () => {
  return {
    visitor: {
      ExportNamedDeclaration(path) {
        if (path.node.declaration.id) {
          APP.modules.push({
            declarationType: path.node.declaration.id.type,
            name: path.node.declaration.id.name,
            node: path.node,
            type: path.node.type,
          });
        }
        if (path.node.declaration.declarations) {
          path.node.declaration.declarations.forEach((declaration) => {
            APP.modules.push({
              declarationType: declaration.id.type,
              name: declaration.id.name,
              node: path.node,
              type: path.node.type,
            });
          });
        }
        if (path.node.specifiers && path.node.specifiers.length >= 1) {
          path.node.specifiers.forEach(specifier => {
            APP.modules.push({
              declarationType: specifier.exported.type,
              name: specifier.exported.name,
              node: path.node,
              type: path.node.type,
            });
          });
        }
      },
      ExportDefaultDeclaration(path) {
        /*APP.modules.push({
          declarationType: path.node.declaration.type,
          name: 'default',
          node: path.node,
          type: path.node.type,
        });*/

        APP.modules.push({
          declarationType: path.node.declaration.type,
          name: path.node.declaration.id.name,
          node: path.node,
          type: path.node.type,
        });
      }
      /*FunctionDeclaration: (path) => {
        console.log(path)
      }*/
    }
  }
}

const getNodes = () => {
  return {
    visitor: {
      IfStatement: {
        enter: (path) => {
          const logicalBranchesGenerator = new LogicalBranchesGenerator(path.node.test);
          APP.testSuite.addDiscribe(logicalBranchesGenerator.getDescribe());
        },
      },
      ConditionalExpression: {
        enter: (path) => {
          const logicalBranchesGenerator = new LogicalBranchesGenerator(path.node.test);
          APP.testSuite.addDiscribe(logicalBranchesGenerator.getDescribe());
        },
      },
      TryStatement: {
        enter: () => {
          const itName = `Error handling - should execute catch for try number ${APP.tryCatchCases.length}`;

          const uniTestCase = new It(itName);
          uniTestCase.generateStructure();
          APP.tryCatchCases.push(uniTestCase);
        },
      },
    }
  };
}

const buildTestFile = () => {
  APP = new App();

  // Set APP.moduleForPlugin
  transformFileSync(FILE, {
    presets: [typescriptPreset],
    plugins: [getModules],
  });

  // Set selected module values
  const selectedModule = APP.modules.find(({ name }) => name === 'isInvalidValue2');
  APP.selectedModuleName = selectedModule.name
  APP.selectedModuleParams = selectedModule.node.declaration.params;
  APP.isAsync = selectedModule.node.declaration.async;

  // Generate main describe
  APP.testSuite = new Describe(`Module ${APP.selectedModuleName}`)

  // Generate first it()
  const firstIt = new It('Should work as expected')
  firstIt.generateStructure();
  APP.testSuite.addTestCase(firstIt);

  // Parse AST to string
  const codeToTransform = generate(selectedModule.node).code

  transformSync(codeToTransform, {
    presets: [typescriptPreset],
    plugins: [getNodes],
    filename: './code3.ts'
  });

  // Add try/catch statements at the end
  APP.tryCatchCases.map(APP.testSuite.addTestCase)

  const code = TEMPLATE({ 
    MODULE_NAME: APP.selectedModuleName,
    TEST_CASES: APP.testSuite.finish(),
   })

  const finalCode = prettier.format(code, { singleQuote: true, tabWidth: 2 })

  fs.writeFileSync('./__tests__/generated.test.ts', finalCode)
}


buildTestFile();